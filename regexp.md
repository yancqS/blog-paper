---
title: 正则表达式30分钟入门教程
date: '2020-12-01'
cover: 'http://img.up-4ever.site/20201203211137.jpeg'
top_img: 'http://img.up-4ever.site/infinity-574531.jpg'
tags:
  - 正则表达式
  - JavaScript
categories:
  - 正则表达式
abbrlink: 522e21a3
---
# 正则表达式30分钟入门教程

## 前言

最早看到这篇文章是在2017年11月8号，那个时候打算认真学一下正则表达式，于是就发现了这篇文章。但是，就在前几天整理打印的文章时，看到这篇文章时发现，当时自己写的笔记、写的表达式，竟然完全不知道是要干啥。其实对于正则表达式而言，就算是自己写的，过个一周半个月的（或者第二天）就看不懂啦要干啥啦。由于平时用正则表达式用的少，也忘的差不多啦。于是打算再来一遍，当时看的版本是V2.3.3，作者是**deerchao**，对作者表示感谢。

本文将以原文为基础，辅以例子验证。

## 如何使用本教程

别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。

除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？

本文介绍的大部分正则语法，在不同的正则表达式引擎中都可以使用，但也有一些会有所差异。本文介绍的是 .Net 下的正则表达式，其它环境下的具体情况可以在读完本文后去参考官方文档，或者查看[正则表达式引擎特性对比](https://www.jb51.net/tools/diffs.html)。

## 正则表达式到底是什么东西？

在编写处理字符串的程序或者网页时，经常会有查找符合某些复杂规则的字符串的需要。**正则表达式**就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。

很可能你使用过Windows/Dos下用于文件查找的**通配符(wildcard)**，也就是\*和？。如果你想查找某个目录下的所有word文件的话，你会搜索\*.doc。在这里，\*就会被解释为任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2～3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像010-12345678或0376-7654321)。
>`^0\d{2,3}-\d{7,8}$`

>(非原文)以下三种表达式都会创建相同的正在表达式：
>1. /ab+c/i; (字面量)
>2. new RegExp('ab+c', 'i'); (构造函数)
>3. new RegExp(/ab+c/, 'i'); (构造函数)

---
>非原文

- lastIndex属性

表示正则表达式下次执行匹配操作时字符串下标位置。

```javascript
var r = /a(b)/g;
console.log(r.lastIndex); // 0
r.test('abcabc'); //true， 从字符串下标0开始匹配
console.log(r.lastIndex); // 2
r.test('abcabc'); //true， 从字符串下标2开始匹配
console.log(r.lastIndex); // 5
```

注意几点：

- 只有指定全局匹配g时，lastIndex才有效，否则一直为0;

```javascript
var r = /a(b)/; // 没有指定全局m
console.log(r.lastIndex); // 0
r.test('abcabc'); //true， 从字符串下标0开始匹配
console.log(r.lastIndex); // 0
r.test('abcabc'); //true， 从字符串下标0开始匹配
console.log(r.lastIndex); // 0
```

- 每次执行全局模式匹配（通过exec或者test方法）时都会影响lastIndex的值;

```javascript
var r = /a(b)/g;
console.log(r.lastIndex); // 0
r.test('abcabc'); //true， 从字符串下标0开始匹配
console.log(r.lastIndex); // 2
r.test('abcabc'); //true， 从字符串下标2开始匹配
console.log(r.lastIndex); // 5
r.test('abcabc'); //false， 从字符串下标5开始匹配
console.log(r.lastIndex); // 0，下次又从头开始匹配了
```

- lastIndex属性是可读写的

```javascript
var r = /a(b)/g;
console.log(r.lastIndex); // 0
r.test('abcabc'); //true， 从字符串下标0开始匹配
console.log(r.lastIndex); // 2
r.test('abcabc'); //true， 从字符串下标2开始匹配
console.log(r.lastIndex); // 5
r.lastIndex = 0; // 修改为0，下次从头开始
r.test('abcabc'); //true， 从字符串下标0开始匹配
console.log(r.lastIndex); // 0，下次又从头开始匹配了
```

---

## 入门

学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。

假设你在一篇英文小说里查找hi，你可以使用正则表达式`hi`。

这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。

不幸的是，很多单词里包含hi这两个连续字符，比如him, history, high等等。用`hi`来查询的话，这里边的hi也会被查出来。如果要精确地查找hi这个单词的话，我们应该用`\bhi\b`。

`\b`是正则表达式规定的一个特殊代码(也有人叫它**元字符，metacharacter**), 代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行符来分隔的，但是`\b`并不匹配这些单词分隔字符中的任何一个，它**只匹配一个位置**。

假如你要找的是hi后面不远处跟着一个Lucy，你应该用`\bhi\b.*\bLucy\b`。

这里，`.`是另一个元字符，匹配**除了换行符**以外的任意字符。`*`同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定`*`前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，`.*`连在一起就意味着任意数量的不包含换行的字符。现在`\bhi\b.*\bLucy\b`的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。

如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：

`0\d\d-\d\d\d\d\d\d\d\d`匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。

这里的`\d`是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。

为了避免那么多烦人的重复，我们也可以这样写这个表达式：`0\d{2}-\d{8}`。这里`\d`后面的`{2}({8})`的意思是前面`\d`必须连续重复匹配2次(8次)。

## 元字符

现在你已经知道几个很有用的元字符了，如`\b`,`.`,`*`，还有`\d`正则表达式里还有更多的元字符，比如`\s`匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。`\w`匹配字母或数字或下划线等。

>(非原文)在原文中表述`\w`是可以匹配字母或数字或下划线或汉字。但是在JavaScript中是不可以匹配汉字的。然后在网上查找了一下资料：
>1. `\w`能不能匹配汉字要视你的操作系统和你的应用环境而定。`\w`匹配任意一个字母或数字或下划线，也就是A～Z,a～z,0～9,_中任意一个。一般来说，是这样的，但是在某些情况下，`\w`也会匹配本地字符集，比如中文系统的中文，全角数字等，所以在明确要求是A～Z,a～z,0～9,_ 中的一个的时候，用[A-Za-z0-9_]，而不用`\w`。

下面看更多例子：

`\ba\w*\b`匹配以字母a开头的单词——先是某个单词开始处(`\b`)，然后是字母a,然后是任意数量的字母或数字(`\w*`)，最后是单词结束处(`\b`)。

`\d+`匹配1个或更多连续的数字。这里的`+`是和`*`类似的元字符，不同的是`*`匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。

`\b\w{6}\b`匹配刚好6个字符的单词。

常用的元字符：


 代码 | 说明
---|---
. | 匹配除换行符意外的任意字符
\w | 匹配字母或数字或下划线
\s | 匹配任意的空白符
\d | 匹配数字
\b | 匹配单词的开头或结尾
^ | 匹配字符串的开始
$ | 匹配字符串的结束

元字符`^`和`$`都匹配一个位置，这和`\b`有点类似。`^`匹配你要用来查找的字符串的开头，`$`匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：`^\d{5,12}$`。

这里的`{5,12}`和前面介绍过的`{2}`是类似的，只不过`{2}`匹配只能不多不少重复2次，`{5,12}`则是重复的次数不能少于5次，不能多于12次，否则都不匹配。

因为使用了`^`和`$`，所以输入的整个字符串都要用来和`\d{5,12}`来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。

>如果不使用^和$的话，对于\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。

和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，`^`和`$`的意义就变成了匹配行的开始处和结束处。

## 字符转义

如果你想查找元字符本身的话，比如你查找`.`,或者`*`,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用`\`来取消这些字符的特殊意义。因此，你应该使用`\.`和`\*`。当然，要查找`\`本身，你也得用`\\`。

例如：`deerchao\.cn`匹配deerchao.cn，`C:\\Windows`匹配C:\Windows。

## 重复

你已经看过了前面的`*`,`+`,`{2}`,`{5,12}`这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如`*`,`{5,12}`等)：

常用的限定符


代码/语法 | 说明
---|---
* | 重复零次或更多次
+ | 重复一次或更多次
？| 重复零次或一次
{n} | 重复n次
{n,} | 重复n次或更多次
{n,m} | 重复n到m次

下面是一些使用重复的例子：

`Windows\d+`匹配Windows后面跟1个或更多数字

`^\w+`匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)

## 字符类

要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？

很简单，你只需要在**方括号**里列出它们就行了，像`[aeiou]`就匹配任何一个英文元音字母，`[.?!]`匹配标点符号(.或?或!)。

我们也可以轻松地指定一个字符范围，像`[0-9]`代表的含意与`\d`就是完全一致的：一位数字；同理`[a-z0-9A-Z_]`也完全等同于\w（如果只考虑英文的话）。

下面是一个更复杂的表达式：`\(?0\d{2}[) -]?\d{8}`。

这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符`\(`,它能出现0次或1次(`?`),然后是一个0，后面跟着2个数字(`\d{2}`)，然后是)或-或空格中的**一个**，它出现1次或不出现(`?`)，最后是8个数字(`\d{8}`)。

>“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。

## 分支条件

不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到**分枝条件**。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用`|`把不同的规则分隔开。听不明白？没关系，看例子：

`0\d{2}-\d{8}|0\d{3}-\d{7}`这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(如0376-2233445)。

`\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}`这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。

>也支持4为区号：`\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}|\(0\d{3}\)[- ]?\d{7}|0\d{3}[- ]?\d{7}`

## 分组

我们已经提到了怎么重复单个字符(直接在字符后面加上限定符就行了)；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。

`(\d{1,3}\.){3}\d{1,3}`是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：`\d{1,3}`匹配1到3位的数字，`(\d{1,3}\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(`\d{1,3}`)。

不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`。

>IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。IP地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。

理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。

>其实`2[0-4]\d|25[0-5]|[01]?\d\d?200-249`匹配的是200-249或250-255或0-199，这不就是0-255吗？

## 反义

有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到**反义**：

常用的反义代码：


代码/语法 |说明
---|---
\W | 匹配任意不是字母，数字，下划线的字符
\S | 匹配任意不是空白符的字符
\D | 匹配任意非数字的字符
\B | 匹配不是单词开头或结束的位置
`[^x]` | 匹配除了x以外的任意字符
`[^aeiou]` | 匹配除了aeiou这几个字母以外的任意字符

例子：`\S+`匹配不包含空白符的字符串。`<a[^>]+>`匹配用尖括号括起来的以a开头的字符串。

## 后向引用

使用**小括号**指定一个子表达式后，**匹配这个子表达式的文本**(也就是此分组捕获的内容)可以在表达式或其他程序中作进一步的处理。默认情况下，每个分组会自动拥有一个**组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

>其实，组号分配还不像我刚说的那么简单：
>- 分组0对应整个表达式
>- 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配——因此所有命名组的组号都大于未命名的组号
>- 你可以使用`(?:exp)`这样的语法来剥夺一个分组对组号分配的参与权．

**后向引用**用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：

`\b(\w+)\b\s+\1\b`可以用来匹配重复的单词，像*go go*, 或者*kitty kitty*。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(`\b(\w+)\b`), 这个单词会被捕获到编号为1的分组中，然后是1个或几个空白字符(`\s+`), 最后是分组1中捕获的内容(也就是前面匹配的那个单词)(`\1`)。

你也可以自己指定子表达式的**组名**。要指定一个子表达式的组名，请使用这样的语法：`(?<Word>\w+)`(或者把尖括号换成`'`也行：`(?'Word'\w+)`), 这样就把`\w+`的组名指定为Word了。要反向引用这个分组**捕获**的内容，你可以使用`\k<Word>`,所以上一个例子也可以写成`\b(?<Word>\w+)\b\s+\k<Word>\b`。

使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：


 分类 | 代码/语法 | 说明
---|---|---
捕获 | (exp) | 匹配exp，并捕获文本到自动命名的组里
捕获 | (?\<name\>exp) | 匹配exp，并捕获文本到名称为name的组里，也可以写成(?'name'exp)
捕获 | (?:exp) | 匹配exp，不捕获匹配的文本，也不给此组分配组号
零宽断言 | (?=exp) | 匹配exp前面的位置(匹配后面是exp的数据)<正向肯定预查>
零宽断言 | (?<=exp) | 匹配exp后面的位置(匹配前面是exp的数据)
零宽断言 | (?!exp) | 匹配后面跟的不是exp的位置
零宽断言 | (?<!exp) | 匹配前面不是exp的位置
注释 | (?#comment) | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读

我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容*不会像前两种那样被捕获到某个组里面，也不会拥有组号*。这在使用或字符`(|)`来组合一个模式的各个部分是很有用。例如`industr(?:y|ies)`就是一个比`industry|industries`更简略的表达式。

## 零宽断言

接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像`\b,^,$`那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：

`(?=exp)` 也叫**零宽度正预测先行断言**, 它断言自身出现的位置的后面能匹配表达式exp。比如`\b\w+(?=ing\b)`，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。再比如，`Windows(?=95|98|NT|2000)`能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。

`(?<=exp)`也叫**零宽度正回顾后发断言**，它断言自身出现的位置的前面能匹配表达式exp。比如`(?<=\bre)\w+\b`会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。

假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：`((?<=\d)\d{3})+\b`，用它对1234567890进行查找时结果是234567890。

下面这个例子同时使用了这两种断言：`(?<=\s)\d+(?=\s)`匹配以空白符间隔的数字(**再次强调，不包括这些空白符**)。

## 负向零宽断言

前面我们提到过怎么查找**不是某个字符或不在某个字符类里**的字符的方法(反义)。但是如果我们只是想**确保某个字符没有出现，但并不想去匹配它**时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：`\b\w*q[^u]\w*\b`匹配包含字母q，但q后面不是字母u的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的`[^u]`将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的`\w*\b`将会匹配下一个单词，于是`\b\w*q[^u]\w*\b`就能匹配整个Iraq fighting。**负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符**。现在，我们可以这样解决这个问题：`\b\w*q(?!u)\w*\b`。

**零宽度负预测先行断言**`(?!exp)`,断言此位置的后面不能匹配表达式exp。例如：`\d{3}(?!\d)`匹配三位数字，而且这三位数字的后面不能是数字；`\b((?!abc)\w)+\b`匹配不包含连续字符串abc的单词。

同理，我们可以用`(?<!exp)`,**零宽度负回顾后发断言**来断言此位置的前面不能匹配表达式exp：`(?<![a-z])\d{7}`匹配前面不是小写字母的七位数字。

一个更复杂的例子：`(?<=<(?<labelName>\w+)>).*(?=<\/\k<labelName>>)`匹配不包含属性的简单HTML标签内里的内容。`(?<=<(\w+)>)`指定了这样的前缀：被尖括号括起来的单词(比如可能是`<b>`)，然后是`.*`(任意的字符串),最后是一个后缀`(?=<\/\1>)`。注意后缀里的`\/`，它用到了前面提过的字符转义；`\1`则是一个反向引用，引用的正是捕获的第一组，前面的`(\w+)`匹配的内容，这样如果前缀实际上是`<b>`的话，后缀就是`</b>`了。整个表达式匹配的是`<b>`和`</b>`之间的内容(**再次提醒，不包括前缀和后缀本身**)。

>`(?<=<(?<labelName>\w+)>).*(?=<\/\k<labelName>>)`这个在原文是这样写的(效果是一样的): `(?<=<(\w+)>).*(?=<\/\1>)`

## 注释

小括号的另一种用途是通过语法(?#comment)来包含注释。例如：`2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`。

要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。

## 贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：`a.*b`，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为**贪婪匹配**。

有时，我们更需要**懒惰匹配**，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样`.*?`就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：

`a.*?b`匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

懒惰限定符


代码/语法 | 说明
---|---
*? | 重复任意次，但尽可能少重复
+? | 重复一次或更多次，但尽可能少重复
?? | 重复零次或一次，但尽可能少重复
{n?} | 重复n次，但尽可能少重复
{n,?} | 重复n次或更多次，但尽可能少重复
{n,m?} | 重复n到m次，但尽可能少重复

## 平衡组/递归匹配

有时我们需要匹配像`(100*(50+15))`这样的可嵌套的层次性结构，这时简单地使用`\(.+\)`则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如`(5/(3+2)))`，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，**配对**的括号之间的内容呢？

为了避免`(`和`\(`把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把`xx<aa<bbb><bbb>aa>yy`这样的字符串里，最长的配对的尖括号内的内容捕获出来？

这里需要用到以下的语法构造：

- `(?'group')`把捕获的内容命名为group，并压入堆栈(stack)
- `(?'-group')`从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本组的匹配失败
- `(?(group)yes|no)`如果堆栈上存在名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
- `(?!)`零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

我们需要做的是每碰到了左括号，就在压入一个"Open",每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空——如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。

```
<                   #最外层的左括号
  [^<>]*            #它后面非括号的内容
  (
      (
        (?'Open'<)  #左括号，压入"Open"
        [^<>]*      #左括号后面的内容
      )+
      (
        (?'-Open'>) #右括号，弹出一个"Open"
        [^<>]*      #右括号后面的内容
      )+
  )*
  (?(Open)(?!))     #最外层的右括号前检查
                    #若还有未弹出的"Open"
                    #则匹配失败

>                   #最外层的右括号
```

>这个平衡组要单独写一篇学习文章。[(flag+1)](http://up-4ever.site/posts/c06a7817/)

平衡组的一个最常见的应用就是匹配HTML，下面这个例子可以匹配嵌套的div标签：`<div[^>]*>[^<>]*(((?'open'<div[^>]*>)[^<>]*)+((?'-open'<\/div>)[^<>]*)+)*(?(open)(?!))<\/div>`

## 还有什么东西没提到

上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们--当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.Net下正则表达式详细的文档。这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看[关于正则表达式语言元素的MSDN在线文档](http://msdn.microsoft.com/zh-cn/library/az24scfc.aspx)。

尚未详细讨论的语法:


代码/语法 | 说明
---|---
\a | 报警字符(打印它的效果是电脑嘀一声)
\b | 通常是单词分界位置，但如果在字符类里使用代表退格
\t | 制表符，Tab
\r | 回车
\v | 竖向制表符
\f | 换页符
\n | 换行符
\e | Escape
\0nn | ASCII代码中八进制代码为nn的字符
\xnn | ASCII代码中十六进制代码为nn的字符
\unnnn | Unicode代码中十六进制代码为nnnn的字符
\cN | ASCII控制字符。比如\cC代表Ctrl+C
\A | 字符串开头(类似^，但不受处理多行选项的影响)
\Z | 字符串结尾或行尾(不受处理多行选项的影响)
\z | 字符串结尾(类似$，但不受处理多行选项的影响)
\G | 当前搜索的开头
\p{name} | Unicode中命名为name的字符类，例如\p{IsGreek}
(?>exp) | 贪婪子表达式
(?\<x\>-\<y\>exp) | 平衡组
(?im-nsx:exp) | 在子表达式exp中改变处理选项
(?im-nsx) | 为表达式后面的部分改变处理选项

## 参考文章
- [正则表达式30分钟入门教程](https://www.jb51.net/tools/zhengze.html)
- [RegExp](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)
- [关于\w能不能匹配中文字符](https://blog.csdn.net/foyoto/article/details/83905794)
- [正则表达式之(exp),(?:exp),(?=exp) 理解](https://blog.csdn.net/wulex/article/details/81356953)
- [JS-RegExp函数](https://segmentfault.com/a/1190000015723611)
- [正则表达式——详细讲解平衡组](https://blog.csdn.net/zm2714/article/details/7946437)